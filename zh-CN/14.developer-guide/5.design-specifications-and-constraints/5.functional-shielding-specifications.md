# 功能屏蔽规范

本文介绍在 OceanBase 中进行数据库使用时需要屏蔽相关功能的规范。

在应用程序设计阶段，使用外键、临时表、视图、自定义函数、存储过程以及触发器对数据库资源的消耗相对略高，从以下几个方面来进行说明。

## 业务和运维层面

### 业务层面

* 业务与数据库逻辑上不要有这种密切的耦合。将业务的逻辑转移至数据库来处理后，业务逻辑强依赖于数据库本身对存储过程、触发器的调用，触发器是否调用成功前端不可控。

* 业务的变更如果涉及到触发器、存储过程、外键等，需要数据库方面额外的操作及流程，不利于前端快速上线。

### 运维层面

* 目前整个数据库业务对前端实现透明，中间层是同构，中间层后面的 OceanBase 实例也是。各同构集群实例间没有功能及数据差异(仅是主从属性不同)，这为我们维护大规模数据库集群提供了便利，是进行自动化运维的基础。但触发器、存储过程、外键等功能容易使得系统处于异构状态,相对应的数据维护、变更等操作, 无论是研发人员或是 DBA，都需要关注集群由此导致的特殊性，需专门记录、维护、操作各个功能所在的具体实例，且操作步骤复杂，特别是在进行主从切换等操作的时候，也带来了更多的判断操作，极不利于统一运维。

* 特殊的实例意味着需要更多的冗余成本。

## 使用的坏处

### 触发器

* 单独将触发器部署在从库上，触发器在压力大的情况下，从库执行语句消耗时间长，会造成从库主从延迟。

* 如果只在从库部署触发器，整个系统处于异构状态，一则难于维护，二来需要对触发器所在服务器单独做冗余，成本增加。

* 如果部署在主库上，不仅导致系统写入性能受影响，触发器中的 SQL 在 STATEMENT（默认同步模式） 下，不会写 BINLOG 同步至从库，也就意味着若要数据同步，从库也得部署触发器，整个系统的性能降低。

* 触发器存在某些场景及版本下导致主从数据不一致，触发器失效等情况。

  比如，多从库部署触发器，某台从库在更新增量表的时候，遇到增量表被业务线程因 for update 锁住，触发器暂时无法插入数据至增量表，此时随着锁表时间的增加，自增表上自增主键的值会随着触发器重试而逐渐增加，以至于当 for update 整个事务 commit 后，自增表新插入的行的自增 ID 已经向上增加了好几个数字，此时从库间数据已不一致。

### 存储过程

* 其日志不利于问题追查定位，其调用在主库全日志里面就是一条 Call productName 日志，在从库上是被真正执行的语句,主库日志不利于定位问题，从库日志上也不利于找到 SQL 语句来源归属。

* 从性能角度而言，执行过程中 SQL 可以避免每次解析，但是对数据库而言，存储过程 SQL 一般均是有着多表，或多判断等语句。这些语句本身性能消耗严重，执行耗时长，会导致系统并发性能下降。需要前端拆解成小的语句来执行，也就没有用存储过程的必要。另外，如果存储过程中有算数运算，也会导致严重的性能问题，如从 1 累加到 1 亿 ，其耗时将达到到 5 分钟，是 C 语言的 1000 倍。

### 外键

* 不推荐外键和级联：如无特殊情况，不推荐使用外键和级联，外键尽量在应用层解决。

* 外键与级联更新适用于单机低并发，不适合分布式、高并发集群。

* 级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。

* 建议每次数据变更都需要对外键做检查。

* 外键给数据恢复带来非常大的困难。DBA 在恢复数据时，若多个表上存在外键依赖，会使得数据恢复流程非常复杂，时间也会增长很多，外键所需要数据逻辑保证完全可通过前端加事务等方式来解决。
