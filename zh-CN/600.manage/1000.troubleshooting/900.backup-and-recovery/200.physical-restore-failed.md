# 物理恢复失败

本节主要介绍物理恢复失败时问题的排查及定位方法。

物理恢复功能对数据备份和日志归档功能具有强依赖，即发起物理恢复前，需要保证至少存在一个可用的备份集，且日志归档连续。

<main id="notice" type='notice'>
<h4>注意</h4>
<ul>
<li>OceanBase 数据库当前仅支持将低版本的备份数据恢复到同版本或高版本中，但不支持将 V3.x 或 V2.x 版本的备份数据恢复到 V4.x 版本中。</li>
<li>对于 OceanBase 数据库 V4.1.0 版本，不支持恢复 OceanBase 数据库 V4.1.0 之前版本的数据。例如，OceanBase 数据库 V4.0.x 版本的备份数据不能恢复到 OceanBase 数据库 V4.1.0 版本中。</li>
</ul>
</main>

## 问题一：执行恢复命令失败

执行 `ALTER SYSTEM RESTORE` 语句发起物理恢复时，命令执行失败，您可以通过以下步骤进行排查处理。

1. 租户管理员登录集群的 `sys` 租户。

2. 执行以下语句，确认报错的错误码。

   ```sql
   SELECT * FROM oceanbase.DBA_OB_ROOTSERVICE_EVENT_HISTORY WHERE module='physical_restore';
   ```

   查询结果中，重点关注以下信息：

   * `result` 对应的值，即报错的错误码。

   * `RS_SVR_IP` 的值，即 Root Service 所在机器的 IP。

3. 根据上一步获取到的 `RS_SVR_IP`，登录 Root Service 所在的机器，搜索 `rootservice.log` 日志，确认报错点。

   1. 登录 Root Service 所在的机器。

   2. 进入日志所在的目录。

      ```shell
      cd /home/admin/oceanbase/log
      ```

   3. 执行以下命令，搜索日志，找到报错点。

      ```shell
      grep "ob_restore_util" rootservice.log | grep "ret=\-4016"
      ```

      其中，`-4016` 为上一步中 `result` 对应的值。

      <main id="notice" type='notice'>
      <h4>注意</h4>
      <p>如果在 <code>rootservice.log</code> 中 <code>grep</code> 不到相关日志，可能是因为 <code>rootservice.log</code> 切了文件，可以执行 <code>grep "ob_restore_util" rootservice.log.* | grep "ret=\-4016"</code>。</p>
      </main>

      常见命令执行失败的报错信息为 `-4018 no enough log for restore.`。该问题通常是由于用户在执行 `ALTER SYSTEM RESTORE` 语句时所指定的恢复终点不正确导致，需要确认在该恢复终点之前是否存在可用的备份集和日志归档。

      可用的备份集和日志归档的判断方法如下：

      * FILE_STATUS = DELETED, 以及 STATUS = OB_SUCCESS
      * a. restore_scn >= 备份集的 min_restore_scn
        b. restore_scn <= 日志归档的 checkpoint_scn

4. 获取搜索到的日志报错信息后，联系技术支持人员协助处理。

## 租户的恢复状态一直卡在 RESTORE_WAIT_LS 状态

执行 `ALTER SYSTEM RESTORE` 语句发起物理恢复后，查看视图 `CDB_OB_RESTORE_PROGRESS`，发现租户的恢复状态一直卡在 `RESTORE_WAIT_LS` 状态，如下所示。

```shell
*************************** 1. row ***************************
                         TENANT_ID: 1
                            JOB_ID: 1
               RESTORE_TENANT_NAME: restore_oracle
                 RESTORE_TENANT_ID: 1
                BACKUP_TENANT_NAME: backup_tenant
                  BACKUP_TENANT_ID: 1002
               BACKUP_CLUSTER_NAME: backup_cluster
                       BACKUP_DEST: file:///data/nfs/backup//archive,file:///data/nfs/backup/data
                    RESTORE_OPTION: pool_list=small_pool_2&primary_zone=z1
                       RESTORE_SCN: NULL
               RESTORE_SCN_DISPLAY: 
                            STATUS: WAIT_TENANT_RESTORE_FINISH
                   START_TIMESTAMP: 
                   BACKUP_SET_LIST: file:///data/nfs/backup/data/backup_set_1_full
                 BACKUP_PIECE_LIST: file:///data/nfs/backup/archive/2_1_2,file:///data/nfs/backup/archive/2_1_3
                       TOTAL_BYTES: NULL
               TOTAL_BYTES_DISPLAY: NULL
                      FINISH_BYTES: NULL
              FINISH_BYTES_DISPLAY: NULL
                       DESCRIPTION:
*************************** 2. row ***************************
                         TENANT_ID: 1002
                            JOB_ID: 1
               RESTORE_TENANT_NAME: mysql
                 RESTORE_TENANT_ID: 1002
                BACKUP_TENANT_NAME: restore_oracle
                  BACKUP_TENANT_ID: 1002
               BACKUP_CLUSTER_NAME: backup_cluster
                       BACKUP_DEST: file:///data/nfs/backup//archive,file:///data/nfs/backup/data
                    RESTORE_OPTION: pool_list=small_pool_2&primary_zone=z1
                       RESTORE_SCN: 1657262084934108000
               RESTORE_SCN_DISPLAY: 2022-07-08 06:34:44.934108
                            STATUS: RESTOE_WAIT_LS
                   START_TIMESTAMP: 
                   BACKUP_SET_LIST: file:///data/nfs/backup/data/backup_set_1_full
                 BACKUP_PIECE_LIST: file:///data/nfs/backup/archive/2_1_2,file:///data/nfs/backup/archive/2_1_3
                       TOTAL_BYTES: 0
               TOTAL_BYTES_DISPLAY: 0.00MB
                      FINISH_BYTES: 0
              FINISH_BYTES_DISPLAY: 0.00MB
                       DESCRIPTION:
2 rows in set
```

有关视图 `CDB_OB_RESTORE_PROGRESS` 的详细字段说明，请参见 [CDB_OB_RESTORE_PROGRESS](../../../700.reference/500.system-reference/400.system-view-of-mysql-mode/200.dictionary-view-of-mysql-mode/9600.oceanbase-cdb_ob_restore_progress-of-mysql-mode.md)。

根据上述获取到的信息，可以按照以下方法进行排查处理。

1. 租户管理员登录集群的 `sys` 租户。

2. 执行以下语句，确认待恢复的租户其日志流副本的恢复状态。

   ```sql
   SELECT ls_id,svr_ip,svr_port,role,restore_status,zone FROM oceanbase.__all_virtual_ls_meta_table WHERE tenant_id = xxx;
   ```

   例如，查询示例如下：

   ```shell
   +-------+----------------+----------+------+----------------+------+
   | ls_id | svr_ip         | svr_port | role | restore_status | zone |
   +-------+----------------+----------+------+----------------+------+
   |     1 | 100.xx.xx.xx   |     5003 |    1 |              0 | z1   |
   |  1001 | 100.xx.xx.xx   |     5003 |    1 |              0 | z1   |
   |  1002 | 100.xx.xx.xx   |     5003 |    1 |              6 | z1   |
   +-------+----------------+----------+------+----------------+------+
   3 rows in set
   ```

   查询结果中，主要关注以下几列信息：

   * `role`：副本角色。`1` 表示 Leader 副本，负责从外部介质恢复数据；`2` 表示 Follower 副本，负责从 Leader 副本拉取恢复数据。
   * `restore_status`：日志流副本的恢复状态：

     * 0：恢复正常完成
     * 1：恢复开始
     * 2：恢复 sys tablet 和创建 user tablet
     * 3：等待 sys tablet 恢复完成
     * 4：恢复 user tablet meta
     * 5：等待恢复 user tablet 完成
     * 6：restore major sst meta, minor sst and replay clog
     * 7：等待 Followers 副本快速恢复
     * 8：finish quick restore, major macro blocks are in remote reference state
     * 9：restore major macro blocks
     * 10：wait followers to restore major macro blocks
     * 11：恢复失败

3. 根据上一步查询结果中日志流副本 `restore_status` 的值，选择对应的方法进一步排查处理。

   * 所有日志流的进度均长时间卡住不推进

     如果所有日志流的进度均长时间卡住不推进，则大概率可以判断是恢复线程卡住，可以通过 obstack 工具来排查是否是 HA_service 线程卡住。

     如果对应租户的 HA_service 堆栈信息显示如下所示信息，则确定为恢复线程卡住，在等待 ls_lock。

   * 日志流副本 `restore_status` 的值为 `6` 或者 `8`

     如果日志流的恢复状态 `restore_status` 值为 `6`，则处于该状态的日志流主要负责从归档目录中完成日志的拉取（包括提交到 palf）及回放。

     <main id="notice" type='notice'>
     <h4>注意</h4>
     <p>由于从 V4.1.0 版本开始，OceanBase 数据库遵循所有恢复日志齐步走的策略，如果有日志流卡在 <code>6</code> 之前的状态，则可能会导致其他日志流的状态都卡在 <code>6</code> 不动。</p>
     </main>

     1. 根据上一步查询到的机器信息，登录到日志流副本所在的机器。

     2. 进入日志所在的目录。

        ```shell
        cd /home/admin/oceanbase/log
        ```

     3. 执行以下命令，搜索日志，确认报错点。

        ```shell
        grep "clog replay not finish, wait later" observer.log |  grep "\[Txxxx\]"
        ```

        其中，`xxxx` 需要替换为恢复租户的 ID。以恢复租户 ID 为 `1002`，命令示例如下：

        ```shell
        grep "clog replay not finish, wait later" observer.log |  grep "\[T1002\]"
        ```

        搜索到的部分日志示例如下：

        ```java script
        observer.log.20220708143857:[2022-07-08 14:38:47.875794] INFO  [STORAGE] leader_quick_restore_ (ob_ls_restore_handler.cpp:1555) [102036][T1002_HAService][T1002][Y138B644564E0-0005E3456E184173-0-0] [lt=5] clog replay not finish, wait later(*ls_={ls_meta:{tenant_id:1002,ls_id{id:1}，replica_type:0, ls_create_status:1, clog_checkpoint_ts:1657261946958110451,clog_base_lsn:{val1:0}, rebuild_sq:0, migration_status:0, gc_state_:1, offline_ts_ns_:-1, restore_status:{status:6}, replayable_point:0, tablet_change_checkpoint_ts:0}, log_handler:{role:2,proposal_id:9223372036854775807, palf_env+:0x7fd8807fe030, is_inited_:true}, restore_handler:{is_inited:true, id:1, proposal_id:1, role:1, parent:NULL, context:{issued:false, last_fetch_ts:-1, max_submit_lsn:{val1:18446744073709551615}, max_fetch_lsn:{val1:18446744073709551615}}} is_inited:true, tablet_gc_handler:{tablet_persist_trigger:0, is_inited:true}})
        ```

        如果搜索结果中有大量上述日志打印，则表示问题与日志回放模块有关，需要确认未回放完成的日志流的 id。

     4. 找到日志流副本 `restore_status` 值为 `6` 的日志流的 Leader。

        ```sql
        SELECT * FROM oceanbase.GV$OB_LOG_STAT WHERE tenant_id = xxxx AND ls_id = yyyy;
        ```

     5. 根据查询到的日志流 Leader，查看日志是否从归档目录恢复到目标租户。

         比较 `GV$OB_LOG_STAT` 中 `end_scn` 的值与内部表 `__all_virtual_tenant_info` 中 `recovery_until_scn` 的值，检查日志是否恢复到租户。其中，`recovery_until_scn` 为租户恢复终点。

        ```sql
        SELECT count(1) FROM oceanbase.GV$OB_LOG_STAT WHERE tenant_id = xxxx AND end_scn < (SELECT recovery_until_scn FROM oceanbase.__all_virtual_tenant_info WHERE tenant_id = xxxx);
        ```

        如果结果为空，则表示日志已从归档目录恢复到目标租户，需要进一步确认日志是否回放完成。

     6. 确认日志是否回放完成。

        查看虚拟表 `__all_virtual_replay_stat`，确认是否有待回放的任务。

        ```sql
        SELECT * FROM oceanbase.__all_virtual_replay_stat WHERE tenant_id = xxxx;
        ```

        查询结果中，重点关注以下几列的值：

        * `pending_cnt`：表示正在等待执行的事务数量。如果该值不为零，则表示有待回放的任务。

        * `end_lsn`：表示日志流的最大可消费位点。如果该值不等于 `unsubmitted_lsn`，则表示有待回放的日志。

     7. 根据确认结果，进行以下处理。

        * 如果确认日志流未回放完成，则可以登录日志流副本 `restore_status` 值为 `6` 的日志流的 Leader 所在的机器，进入日志目录后，执行以下命令，查看节点回放日志。

          ```shell
          grep Txxxx_Rep observer.log
          ```

          其中，`xxxx` 需要替换为恢复租户的 ID。以恢复租户 ID 为 `1002`，命令示例如下：

          ```shell
          grep T1002_Rep observer.log
          ```

          搜索到的相关日志信息后，联系技术支持人员协助处理。

        * 如果确认日志流回放完成，但日志流副本 `restore_status` 的值为仍为 `6`，可以登录日志流副本 `restore_status` 值为 `6` 的日志流的 Leader 所在的机器，进入日志目录后，执行以下命令，确认一下状态机推进线程是否在工作以及是否有报错。

          ```shell
          grep 'ls_restore_handle' observer.log
          ```

          根据日志报错结果，如果确认是状态机推进线程的问题，请联系技术支持人员协助处理。

   * 日志流副本 `restore_status` 的值为 `13`

     处于该状态时，表示日志流恢复失败，但未汇报给 Root Service。可以通过以下方法进行排查。

     1. 租户管理员登录集群的 `sys` 租户。
     2. 查询内部表 `__all_virtual_ls_restore_progress`，获取日志流所在的 OBServer 节点 IP 和 `trace_id` 信息。

        ```sql
        SELECT * FROM oceanbase.__all_virtual_ls_restore_progress WHERE tenant_id = xxxx AND ls_id = xxxx; 
        ```

        查询结果中，重点关注以下几列的值：

        * `svr_ip`：日志流所在 OBServer 节点的 IP。
        * `result`：值为 `0` 表示正常；值不为 `0` 时表示恢复失败任务的错误码信息。
        * `comment`：显示日志流恢复失败的相关信息，包括错误码、`trace_id` 等信息。

     3. 根据获取到的 `svr_ip` 信息和 `trace_id` 信息，登录对应的机器，进入日志目录，执行以下命令，搜索日志。

        ```sql
        grep "trace_id" observer.log* | grep "ret=\-4722" 
        ```

        其中，`trace_id` 需要替换成 `comment` 中的 trace_id 信息；`-4722` 需要替换为 `result` 中显示的错误码信息。

     4. 搜索到相关日志报错信息后，联系技术支持人员协助处理。

   * 日志流副本 `restore_status` 为其他状态

     当日志流副本的 `restore_status` 的值为除了 `6`、`8`、`13` 以外的其他值时，可以通过内部表 `__all_virtual_dag_scheduler` 确认 `restore_dag` 和 `DAG_NET_RESTORE` 的执行情况。

     1. 租户管理员登录集群的 `sys` 租户。
     2. 查询内部表 `__all_virtual_dag_scheduler`。

        ```sql
        SELECT * FROM oceanbase.__all_virtual_dag_scheduler;
        ```

     3. 根据查询结果，如果确认并发度低，可调大恢复线程的并发参数 `ha_high_thread_score`。

        ```sql
        ALTER SYSTEM SET ha_high_thread_score = 100 tenant =xxxx;
        ```

## schema 刷新问题

执行 `ALTER SYSTEM RESTORE` 语句发起物理恢复后，查看视图 `CDB_OB_RESTORE_PROGRESS`，发现租户的恢复状态不处于 `RESTORE_WAIT_LS` 而是卡在其他状态，并且仅系统租户存在残留时，只有可能是租户的 Schema 未刷新出来，导致 create_tenant_end 失败。

您可以通过以下方法进行排查处理：

1. 租户管理员登录集群的 `sys` 租户。

2. 查询视图 `GV$OB_SERVER_SCHEMA_INFO`，确认 Schema 的刷新进度。

   ```sql
   SELECT * FROM oceanbase.GV$OB_SERVER_SCHEMA_INFO WHERE tenant_id=xxxx;
   ```

   查询示例如下：

   ```shell
   +----------------+----------+-----------+--------------------------+-------------------------+--------------+-------------+----------------------------+
   | SVR_IP         | SVR_PORT | TENANT_ID | REFRESHED_SCHEMA_VERSION | RECEIVED_SCHEMA_VERSION | SCHEMA_COUNT | SCHEMA_SIZE | MIN_SSTABLE_SCHEMA_VERSION |
   +----------------+----------+-----------+--------------------------+-------------------------+--------------+-------------+----------------------------+
   | xx.xx.xx.5     |     4000 |      1002 |                        1 |                       1 |            4 |     1086    |                         -1 |
   | xx.xx.xx.9     |     4002 |      1002 |                        1 |                       1 |            4 |     1086    |                         -1 |
   | xx.xx.xx.9     |     4001 |      1002 |                        1 |                       1 |            4 |     1086    |                         -1 |
   | xx.xx.xx.5     |     4005 |      1002 |                        1 |                       1 |            4 |     1086    |                         -1 |
   | xx.xx.xx.11    |     4004 |      1002 |                        1 |                       1 |            4 |     1086    |                         -1 |
   | xx.xx.xx.11    |     4003 |      1002 |                        1 |                       1 |            4 |     1086    |                         -1 |
   +----------------+----------+-----------+--------------------------+-------------------------+--------------+-------------+----------------------------+
   6 rows in set
   ```

   根据查询结果可知，`MIN_SSTABLE_SCHEMA_VERSION` 为 `-1`，表示 Schema 未刷新出来，需要搜索日志继续排查。

3. 根据上一步视图中获取到的信息，可以选择任意一台机器登录后，进入日志所在目录，搜索日志获取 trace 信息。搜索日志时，直接按照线程名搜索即可。

   由于 Schema 刷新是后台线程，系统会一直重试，故只需查看最新的日志即可。

   ```shell
   grep "SerScheQueue0" observer.log
   ```

   搜索到的日志示例如下：

   ```javascript
   observer.log.20220811114045:[2022-08-11 11:39:54.382533] WARN  [RPC.OBRPC] rpc_call (ob_rpc_proxy.ipp:361) [192069][SerScheQueue0][T0][YFA00BA2D905-0005E5DEE6A2294E-0-0] [lt=8] execute rpc fail(ret=-4012, dst="11.162.217.9:4001")
   observer.log.20220811114045:[2022-08-11 11:39:54.382552] WARN  log_user_error_and_warn (ob_rpc_proxy.cpp:315) [192069][SerScheQueue0][T0][YFA00BA2D905-0005E5DEE6A2294E-0-0] [lt=20]
   ```

   在搜索结果中，找到对应的 trace 信息。例如，示例中的 trace 信息为 `YFA00BA2D905-0005E5DEE6A2294E-0-0`。

4. 根据获取到的 trace 信息，继续执行以下命令，搜索日志确认报错信息。

   ```shell
   grep "YFA00BA2D905-0005E5DEE6A2294E-0-0" observer.log.xxxx
   ```

5. 获取到日志报错信息后，联系技术支持人员协助处理。

## 视图中恢复任务的状态为 FAILED

执行 `ALTER SYSTEM RESTORE` 语句发起物理恢复后，查看视图 `CDB_OB_RESTORE_HISTORY`，发现恢复任务的状态为 `FAILED`。有关视图 `CDB_OB_RESTORE_HISTORY` 的详细介绍，请参见 [CDB_OB_RESTORE_HISTORY](../../../700.reference/500.system-reference/400.system-view-of-mysql-mode/200.dictionary-view-of-mysql-mode/9500.oceanbase-cdb_ob_restore_history-of-mysql-mode.md)。

根据视图 `CDB_OB_RESTORE_HISTORY` 的查询结果：

* 如果视图 `CDB_OB_RESTORE_HISTORY` 中 `comment` 列的信息为空

  `comment` 列的信息为空，您可以通过以下步骤进行排查：

  1. 租户管理员登录集群的 `sys` 租户。
  2. 查询内部表 `__all_virtual_ls_meta_table`，找到 `restore_status` 列的值为 `11` 的日志流。

      ```sql
      SELECT * FROM oceanbase.__all_virtual_ls_meta_table WHERE tenant_id=xxx;
      ```

     在查询结果中，找到 `restore_status` 列的值为 `11` 的日志流，同时记录其对应的 `svr_ip`。

  3. 根据上一步获取到的 `svr_ip`，登录到对应的机器。

  4. 进入日志所在的目录。

     ```shell
     cd /home/admin/oceanbase/log
     ```

  5. 执行以下命令，搜索失败任务时间附近的日志，获取对应的 trace_id。

     ```shell
     grep "ls restore failed, tenant restore can't continue" observer.log
     ```

     根据搜索到的日志，记录对应的 trace_id。

  6. 根据获取到的 trace_id，执行以下命令，继续搜索相关日志。

      ```shell
      grep "trace_id"  observer.log | grep "WARN\|ERROR"
      ```

      其中，`trace_id` 需要替换成上一步的 trace_id 信息。

  7. 搜索到日志报错信息后，联系技术支持人员协助处理。
  
* 如果视图 `CDB_OB_RESTORE_HISTORY` 中 `comment` 列的信息不为空
  
  `comment` 列中展示了恢复任务相关的一些信息，包括 OBServer 节点的 IP、日志流 id、出错模块类型以及对应的 trace_id。您可以通过以下信息进行排查，具体步骤如下：

  1. 登录到 `comment` 信息中所指示的机器。

  2. 进入日志所在目录。

     ```shell
     cd /home/admin/oceanbase/log
     ```

  3. 执行以下命令，搜索恢复任务失败时间点附近的日志。

     * 如果该机器是 OBServer 节点（`comment` 信息中显示为 `(server)`），则执行以下命令搜索恢复任务失败时间点附近的日志。

         ```shell
       grep "trace_id"  observer.log | grep "WARN\|ERROR"
       ```

       其中，`trace_id` 需要替换成上一步的 trace_id 信息。

       <main id="notice" type='notice'>
       <h4>注意</h4>
       <p>如果在 <code>observer.log</code> 中 <code>grep</code> 不到相关日志，可能是因为 <code>observer.log</code> 切了文件，可以 <code>grep "trace_id" observer.log.* | grep "WARN\|ERROR"</code>。</p>
       </main>

     * 如果该机器是 ROOT Service（`comment` 信息中显示为 `(rootservice)`），则执行以下命令搜索恢复任务失败时间点附近的日志。

       ```shell
       grep "ob_restore_scheduler" rootservice.log | grep "WARN\|ERROR" 
       ```

       <main id="notice" type='notice'>
       <h4>注意</h4>
       <p>如果在 <code>rootservice.log</code> 中 <code>grep</code> 不到相关日志，可能是因为 <code>rootservice.log</code> 切了文件，可以 <code>grep "ob_restore_scheduler" rootservice.log.* | grep "WARN\|ERROR"</code>。</p>
       </main>

  4. 搜索到日志报错信息后，联系技术支持人员协助处理。
