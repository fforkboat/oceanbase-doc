# SQL 优化实践

某客户数据库系统发生性能故障，发生大量交易拥堵的现象，直接原因是部分 OceanBase 数据库服务器节点的 CPU 使用率达到 100%，导致交易无法正常办理。通过查询 `GV$OB_SQL_AUDIT` 视图抓取信息进行分析，定位到一条问题 SQL 的平均耗时为 2s，并且改 SQL 总的 CPU 使用量超过该服务器节点 CPU 资源的 80%，经过一系列的优化后，使得该 SQL 的 CPU 耗时降至 4 ms，彻底解决了性能瓶颈问题。

本案例的排查和优化思路如下：

1. 通过查询 `GV$OB_SQL_AUDIT` 视图定位问题 SQL。

执行如下 SQL 语句查询 `GV$OB_SQL_AUDIT` 视图定位问题 SQL，主要查询问题发生 30 分钟的时间段内指定的 OBserver 节点上（`svr_ip`）的 SQL (`GROUP BY sql_id`) 相比于问题时间段内总 CPU 的使用率（`SUM(execute_time)/(30*60*1000*1000）AS cup_cnt`）等信息。

```shell
SELECT sql_id,
       COUNT(*)               AS executions,
       SUM(execute_time)      AS tot_cup_time,
       AVG(execute_time)      AS avg_cup_time,
       SUM(execute_time)      AS cup_cnt,
       query_sql
    FROM oceanbase.GV$OB_SQL_AUDIT
    WHERE tenant_id= 'mysql001'
        AND svr_ip='172.30.135.192'
        AND request_time BETWEEN (TIME_TO_USEC(NOW())-30*60*1000*1000) AND TIME_TO_USEC(NOW())
        AND is_executor_rpc =0 
        GROUP BY sql_id
        HAVING COUNT(*)>1
        ORDER BY cup_cnt DESC LIMIT 10;
```

查询得到如下 SQL 的执行频率和 CPU 使用率较高，而且集中与同一台 OBServer 节点上。

```shell
SELECT AAZ664 AS unitMainId,AAB001 AS unitId,AAB999 AS unitNumber,AAB003 AS unitMainOrganizationCode,AAB998 AS unitMainSocialCreditCode,AAB004 AS unitMainName,AAB019 AS unitType,AAA120 AS profileStatus,AAB021 AS subRelation,AAB020 AS economicsType,AAB022 AS businessCode,AAB006 AS registType,AAB007 AS licenseNo,AAB008 AS licenseDate,AAB009 AS licenseExpiryDate,AAB023 AS adminUnit,AAE048 AS approveDepartment,AAE049 AS approveDate,AAE051 AS approveFileNumber,AAB013 AS legalName,AAC058 AS legalIdCardType,AAC147 AS legalIdCardNumber,AAE005 AS legalPhone,AAB030 AS taxNumber,AAB301 AS stateCode,AAZ649 AS unitMainOperateId,AAZ649 AS unitBusiOperateId,AAB365 AS parentUnitId,AAA149 AS industryRiskCategory,AAB363 AS unitUniqueId,AAB996 AS baseStoreId,AAB366 AS virtualUnitFlag,AAB355 AS certificationUnit,AAB356 AS businessScope,AAE047 AS establishDate,AAB361 AS registerAddress,AAB078 AS registerState,AAB065 AS specialUnitType,AAC161 AS regionCode,AAE858 AS segmentationRule,AAZ692 AS operateUserLoginId,AAF018 AS provinceState,AAA431 AS databaseKey,AAZ673 AS dataUniqueCode,AAA508 AS operateDataMark,AAE013 AS comments,AAE860 AS creator,AAE859 AS createTime,AB01_AAE011 AS operator,AB01_AAE036 AS operateTime,AB01_AAA027 AS socialPoolCode,AAB002 AS socialInsuranceNumber,CAB001 AS unitSocialSecurityNumber,AAE006 AS unitAddress,AAE007 AS zipCode,AAE046 AS email,AAB041 AS fax,CAB004 AS organizationDate,CAB005 AS certificateDate,CAB014 AS certificateUnitName,CAB002 AS licensingAgency,CAB006 AS certificateNumber,CAB011 AS licensingNumber,AAB038 AS businessRegisteredAddress,AAB049 AS businessTypeNumber,AAB032 AS taxName,CAB007 AS taxDate,AAB034 AS unitOrgCode,CAB015 AS pensionIndustryCode,CAB024 AS oldInjuryIndustryCode,CAB025 AS competentDepartmentNumber,CAB026 AS headOfficeUnitNumber,AAE199 AS specialUnitFlag,AAE300 AS sharingStatus,ZAB100 AS distinguishingMark,CAB020 AS temporaryEmploymentType,CAB030 AS organizationType,CAB031 AS organizationIssuingUnit,CAB032 AS organizationTermAlidity,AAF001 AS unitNature,AAF002 AS fundsSource,AAF007 AS unitEstablishment,AAF003 AS retireNumber,AAF004 AS staffNumber,AAF005 AS financeAppropriationNumber,AAF006 AS notFinanceAppropriationNumber,AAF008 AS departmentOrganizationNumber,AAF009 AS departmentSocialSecurityNumber,AAF020 AS anotherFileManagementFlag,AAF021 AS anotherFileManagementStartDate,AAF022 AS anotherFileManagementEndDate,AAF023 AS manageLevel,AAF024 AS budgetUnitNumber,AAF025 AS financeContributionsNature,AAF027 AS industrialInjuryCode,AAF028 AS laborDispatchFlag,AAF029 AS laborDispatchType,AAF030 AS laborDispatchCode,AAF031 AS feeReductionFlag,AAF032 AS deferredPaymentFlag,AAF033 AS reductionFeeType,AAF034 AS isReductionPromise,AAF035 AS publicityBatch,AAF036 AS publicityStartDate,AAF037 AS reliefType,BAB400 AS oldPensionNumber,AAB016 AS contactPersonName,AAB017 AS contactPersonBelong,AAB018 AS contactPersonPhone,AAB039 AS fundContactPersonName,AAB043 AS fundContactPersonBelong,AAB040 AS fundContactPersonPhone,CAB013 AS paymentAbility,CAB012 AS applyInsuredDate,CAB017 AS registrationReason,AAE145 AS mainAgency,CAB021 AS suspendPayFlag,BAB023 AS socialWageProportion,BAB042 AS difficultEnterprise,BAB043 AS laptopEnterprise,BAB045 AS smallEnterprises,CAB027 AS arrearsTransferFlag,CAB028 AS laptopStartDate,CAB029 AS laptopEndDate,BAB030 AS smallStartDate,BAB031 AS smallEndDate,AAE400 AS ObjType,AAB400 AS oldUnitNumber,AAA140 AS fundCollectionCode,AAB033 AS taxSequenceNumber,AAB031 AS payTaxPartition,AAE119 AS unitState,CAB023 AS isPayBase,AAB098 AS difficultUnitFlag,AAB099 AS oldInjuryUnitFlag,CAB018 AS specialUnitSign,CAB160 AS landName,CAB161 AS landNumber,CAB162 AS landOrganizationName,CAB163 AS landGroundNumber,CAB164 AS landCompensation,CAB165 AS farmLandNumber,CAB166 AS oldPersonCount,CAB168 AS specialPersonCount,CAB169 AS middlePersonCount,CAB170 AS landMoney,CAB171 AS socialOperator,CAB172 AS socialOperatorPhone,AAE036 AS operateDate,BAE010 AS littleUnitAccount,BAZ002 AS operateID,BAE012 AS bigName,AAE009 AS accountName,AAC155 AS bankName,AAE010 AS accountNumber,distinguish,ZB10_AAB031 AS validity,aac023,AAF002_ZB10 AS bankNumber FROM V_AB01 WHERE (AAB001 IN (20017476))
```

2. 查询问题 SQL 的 Explain 信息

通过执行 `EXPLAIN EXTENDED` 命令得到改问题 SQL 的 Explain 信息如下：

```shell
=================================================================================
|ID|OPERATOR                             |NAME                 |EST. ROWS|COST  |
---------------------------------------------------------------------------------
|0 |EXCHANGE IN REMOTE                   |                     |177      |432961|
|1 | EXCHANGE OUT REMOTE                 |                     |177      |397632|
|2 |  SUBPLAN SCAN                       |V_AB01               |177      |397632|
|3 |   UNION ALL                         |                     |177      |397629|
|4 |    NESTED-LOOP JOIN CARTESIAN       |                     |0        |151990|
|5 |     TABLE SCAN                      |ABA1(IDX_ABA1_AAB001)|1        |92    |   
|6 |     MATERIAL                        |                     |0        |151899|
|7 |      NESTED-LOOP ANTI JOIN CARTESIAN|                     |0        |151899|
|8 |       TABLE SCAN                    |AB01(IDX_AB01_AAB001)|1        |92    |
|9 |       MATERIAL                      |                     |177      |151781|
|10|        SUBPLAN SCAN                 |VIEW1                |177      |151780|
|11|         TABLE SCAN                  |ZB10(IDX_ZB10_BAZ170)|177      |151777|
|12|    NESTED-LOOP JOIN CARTESIAN       |                     |177      |236327|
|13|     TABLE GET                       |ABC1                 |1        |46    |
|14|     TABLE SCAN                      |ZB10(IDX_ZB10_BAZ170)|177      |235510|
=================================================================================

Outputs & filters: 
-------------------------------------

  5 - output(......), filter(nil), 
      access(......), partitions(p0), 
      is_index_back=true, 
      range_key([ABA1.AAB001(0x7f510ed97860)], [ABA1.AAZ001(0x7f48eec9baa0)]), range(20017476,MIN ; 20017476,MAX), 
      range_cond([ABA1.AAB001(0x7f510ed97860) = 20017476(0x7f510edbd750)])

  8 - output(......), filter(nil), 
      access(......), partitions(p0), 
      is_index_back=true, 
      range_key([AB01.AAB001(0x7f510ed97570)], [AB01.AAZ664(0x7f510ed97b50)]), range(20017476,MIN ; 20017476,MAX), 
      range_cond([AB01.AAB001(0x7f510ed97570) = 20017476(0x7f510edbcc50)])

 11 - output(......), filter([20017476 = cast(cast(ZB10.BAZ170(0x7f3f5b51c090), VARCHAR2(20 BYTE))(0x7f3f5b51d6b0), NUMBER(-1, -85))(0x7f3f5b51ce80)(0x7f3f5b51c380)]), 
      access(......), partitions(p0), 
      is_index_back=false, filter_before_indexback[false],   
      range_key([ZB10.BAZ170(0x7f3f5b51c090)], [ZB10.AAZ001(0x7f3f5b528e80)]), range(MIN,MIN ; MAX,MAX)always true  // range: always true

 13 - output(......), filter(nil), 
      access(......), partitions(p0), 
      is_index_back=false, 
      range_key([ABC1.AAZ509(0x7f0cb0ff9f20)]), range[20017476 ; 20017476], 
      range_cond([ABC1.AAZ509(0x7f0cb0ff9f20) = 20017476(0x7f0cb1001170)])

 14 - output(......), filter([20017476 = cast(cast(ZB10.BAZ170(0x7f0cb0ffa210), VARCHAR2(20 BYTE))(0x7f0cb1002fa0), NUMBER(-1, -85))(0x7f0cb1002770)(0x7f0cb1001c70)]), 
      access(......), partitions(p0), 
      is_index_back=true, filter_before_indexback[true],
      range_key([ZB10.BAZ170(0x7f0cb0ffa210)], [ZB10.AAZ001(0x7f3f5b582c10)]), range(MIN,MIN ; MAX,MAX)always true // range: always true


Used Hint:
-------------------------------------
  /*+

  */

Outline Data:
------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" ("LOCAL_BDZGBGYY.ABA1"@"SEL$2" ("EINP_BASICINFO.AB01"@"SEL$2" "VIEW1"@"SEL$2" )))
      USE_NL(@"SEL$2" ("EINP_BASICINFO.AB01"@"SEL$2" "VIEW1"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("EINP_BASICINFO.AB01"@"SEL$2" "VIEW1"@"SEL$2" ))
      INDEX(@"SEL$2" "LOCAL_BDZGBGYY.ABA1"@"SEL$2" "IDX_ABA1_AAB001")
      USE_NL(@"SEL$2" ("VIEW1"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("VIEW1"@"SEL$2" ))
      INDEX(@"SEL$2" "EINP_BASICINFO.AB01"@"SEL$2" "IDX_AB01_AAB001")
      INDEX(@"SEL$3" "LOCAL_BDZGBGYY.ZB10"@"SEL$3" "IDX_ZB10_BAZ170")
      LEADING(@"SEL$4" ("SICP4_BASICINFOCENTER_EINP.ABC1"@"SEL$4" "LOCAL_BDZGBGYY.ZB10"@"SEL$4" ))
      USE_NL(@"SEL$4" ("LOCAL_BDZGBGYY.ZB10"@"SEL$4" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$4" ("LOCAL_BDZGBGYY.ZB10"@"SEL$4" ))
      FULL(@"SEL$4" "SICP4_BASICINFOCENTER_EINP.ABC1"@"SEL$4")
      INDEX(@"SEL$4" "LOCAL_BDZGBGYY.ZB10"@"SEL$4" "IDX_ZB10_BAZ170")
      END_OUTLINE_DATA
  */

Plan Type:
-------------------------------------
REMOTE

Optimization Info:
-------------------------------------      
ABA1:table_rows:533243, physical_range_rows:1, logical_range_rows:1, index_back_rows:1, output_rows:1, est_method:remote_storage, optimization_method=cost_based, avaiable_index_name[IDX_ABA1_AAB001], pruned_index_name[IDX_ABA1_BAZ002,IDX_ABA1_BZE300,IDX_ABA1_AAB031,IDX_ABA1_AAF001,IDX_ABA1_CAB026], unstable_index_name[ABA1], estimation info[table_id:1113805279004842, (table_type:1, version:0-1672855210317669-1672855210317669, logical_rc:1, physical_rc:1), (table_type:7, version:1672855201910039-1672855201910039-1672855243026529, logical_rc:0, physical_rc:0), (table_type:7, version:1672855243026529-1672855243026529-1672858809751352, logical_rc:0, physical_rc:0), (table_type:5, version:1672855243026529-1672855243026529-1672858809751352, logical_rc:0, physical_rc:0), (table_type:0, version:1672858809751352-1672858809751352-9223372036854775807, logical_rc:0, physical_rc:0)]

AB01:table_rows:498204, physical_range_rows:1, logical_range_rows:1, index_back_rows:1, output_rows:1, est_method:remote_storage, optimization_method=cost_based, avaiable_index_name[IDX_AB01_AAB001], pruned_index_name[IDX_AB01_AAB003,IDX_AB01_AAB004,IDX_AB01_AAB363,IDX_AB01_AAB998,IDX_AB01_AAB999,IDX_AB01_AAZ649,IDX_AB01_AAZ673,IDX_AB01_AAA350,IDX_AB01_T0CHAR_AAB001], unstable_index_name[AB01], estimation info[table_id:1113805279004850, (table_type:1, version:0-1672855210317669-1672855210317669, logical_rc:1, physical_rc:1), (table_type:7, version:1672855201605318-1672855201605318-1672855242720866, logical_rc:0, physical_rc:0), (table_type:7, version:1672855242720866-1672855242720866-1672858809445871, logical_rc:0, physical_rc:0), (table_type:5, version:1672855242720866-1672855242720866-1672858809445871, logical_rc:0, physical_rc:0), (table_type:0, version:1672858809445871-1672858809445871-9223372036854775807, logical_rc:0, physical_rc:0)]

ZB10:table_rows:35374, physical_range_rows:35404, logical_range_rows:35389, index_back_rows:0, output_rows:176, est_method:local_storage, optimization_method=cost_based, avaiable_index_name[IDX_ZB10_BAZ170,ZB10], pruned_index_name[IDX_ZB10_AAB001], estimation info[table_id:1113805279034827, (table_type:1, version:0-1672855210317669-1672855210317669, logical_rc:35374, physical_rc:35374), (table_type:7, version:1672855201148820-1672855201148820-1672855243647482, logical_rc:0, physical_rc:0), (table_type:7, version:1672855243647482-1672855243647482-1672858813210627, logical_rc:0, physical_rc:0), (table_type:5, version:1672855243647482-1672855243647482-1672858813210627, logical_rc:0, physical_rc:0), (table_type:0, version:1672858813210627-1672858813210627-9223372036854775807, logical_rc:15, physical_rc:30)]

ABC1:table_rows:100000, physical_range_rows:1, logical_range_rows:1, index_back_rows:0, output_rows:1, est_method:local_storage, optimization_method=rule_based, heuristic_rule=unique_index_without_indexback

ZB10:table_rows:35374, physical_range_rows:35404, logical_range_rows:35389, index_back_rows:176, output_rows:176, est_method:local_storage, optimization_method=cost_based, avaiable_index_name[IDX_ZB10_BAZ170,ZB10], pruned_index_name[IDX_ZB10_AAB001], estimation info[table_id:1113805279034827, (table_type:1, version:0-1672855210317669-1672855210317669, logical_rc:35374, physical_rc:35374), (table_type:7, version:1672855201148820-1672855201148820-1672855243647482, logical_rc:0, physical_rc:0), (table_type:7, version:1672855243647482-1672855243647482-1672858813210627, logical_rc:0, physical_rc:0), (table_type:5, version:1672855243647482-1672855243647482-1672858813210627, logical_rc:0, physical_rc:0), (table_type:0, version:1672858813210627-1672858813210627-9223372036854775807, logical_rc:15, physical_rc:30)]
```

由上述 `EXPALIN` 信息，可以得到该条 SQL 的执行总代价估算为 432961，代价主要体现在 `UNION ALL` 部分（代价估算为 397629），它的两个分支都包含 `NESTED-LOOP JOIN`，代价估算分别为 151990 和 236327。`UNION ALL` 部分第一个分支（包括 4 号到 11 号算子）的主要代价体现在通过索引 `ZB10(IDX_ZB10_BAZ170)` 去做 `TABLE SCAN` 的 11 号算子上面；第二个分支（包括 12 号到 14 号算子）的主要代价也体现在通过索引 `ZB10(IDX_ZB10_BAZ170)` 去做 `TABLE SCAN` 的 14 号算子上面。由此可见 11 号算子和 14 号算子都是由于 `ZB10` 的索引而导致代价整体偏高。

再进一步分析 11 号算子和 14 号算子的 Outputs & filters 信息，`range(MIN,MIN ; MAX,MAX)always true` 表明没有做索引匹配， `filter([20017476 = cast(cast(ZB10.BAZ170(0x7f0cb0ffa210), VARCHAR2(20 BYTE))(0x7f0cb1002fa0), NUMBER(-1, -85))(0x7f0cb1002770)(0x7f0cb1001c70)])` 表明在访问时产生数据类型的转换，由此得知关联字段的数据类型不统一而进行的数据类型的转换导致了不可走索引。

```sql
 11 - output(......), filter([20017476 = cast(cast(ZB10.BAZ170(0x7f3f5b51c090), VARCHAR2(20 BYTE))(0x7f3f5b51d6b0), NUMBER(-1, -85))(0x7f3f5b51ce80)(0x7f3f5b51c380)]), 
      access(......), partitions(p0), 
      is_index_back=false, filter_before_indexback[false],   
      range_key([ZB10.BAZ170(0x7f3f5b51c090)], [ZB10.AAZ001(0x7f3f5b528e80)]), range(MIN,MIN ; MAX,MAX)always true  // range: always true

 14 - output(......), filter([20017476 = cast(cast(ZB10.BAZ170(0x7f0cb0ffa210), VARCHAR2(20 BYTE))(0x7f0cb1002fa0), NUMBER(-1, -85))(0x7f0cb1002770)(0x7f0cb1001c70)]), 
      access(......), partitions(p0), 
      is_index_back=true, filter_before_indexback[true],
      range_key([ZB10.BAZ170(0x7f0cb0ffa210)], [ZB10.AAZ001(0x7f3f5b582c10)]), range(MIN,MIN ; MAX,MAX)always true // range: always true
```

1. 进行 DDL 分析

首先，分析视图 `V_AB01` 的定义中可知, `UNION ALL` 的第一个分支中 `zb10` 存在于 `NOT EXISTS` 子查询中，结合 `EXPLAIN` 信息，可以得出相关子查询被改写为 `NESTED-LOOP ANTI JOIN`。此外，视图 `V_AB01` 发生了 `TO_NUMBER` 转换，其中的 `aab001` 和 `aaz509` 会传递给索引 `ZB10(IDX_ZB10_BAZ170)`。

接下来，分析表 `ZB10` 的定义可知，索引 `ZB10(IDX_ZB10_BAZ170)` 定义于 `ZB10` 字段，数据类型为 `VARCHAR2(20)`，而该字段就是视图 `V_AB01` 与其他表进行关联的字段，即在视图 `V_AB01` 定义的 `UNION ALL` 第一个分支中，11 号算子对应的关联 `"zb10"."baz170" = "ab01"."aab001" = 20017476`, 第二个分支中 14 号算子对应的关联 `"zb10"."baz170" = "abc1"."aaz509" = 20017476`，可见由于关联字段数据类型不一致而发生了 `TO_NUMBER` 转换，即将 `ZB10` 字段的 `VARCHAR2` 类型强制转换为了 `NUMBER`。

综合 DDL 信息和 `EXPALIN` 可知，To_number 强制转换导致索引性能下降，造成 11 号和 14 号算子的代价估算较大。

```sql
/* 问题 SQL 的定义 */
SELECT ......
FROM   v_ab01
WHERE  AAB001 IN (20017476)；

/* 视图 V_AB01 的定义 */
CREATE VIEW "V_AB01_OLD"
AS
  (SELECT  
          To_number("LOCAL_CXZX"."ab01"."aab001") AS "AAB001",   // To_number 强制转换不合理，应该去掉
          ... ...
   FROM   "LOCAL_CXZX"."ab01",
          "LOCAL_CXZX"."aba1"
   WHERE  ( "LOCAL_CXZX"."ab01"."aab001" = "LOCAL_CXZX"."aba1"."aab001" )
          AND NOT EXISTS((SELECT 1
                          FROM   "LOCAL_CXZX"."zb10"
                          WHERE  ( "LOCAL_CXZX"."ab01"."aab001" =
                                   "LOCAL_CXZX"."zb10"."baz170"
                                 ))))
  
  UNION ALL

  (SELECT  
          To_number("LOCAL_CXZX"."abc1"."aaz509") AS "AAB001",   // To_number 强制转换不合理，应该去掉
          ... ... 
   FROM   "LOCAL_CXZX"."abc1",
          "LOCAL_CXZX"."zb10" "ZB10"
   WHERE  ( "LOCAL_CXZX"."abc1"."aaz509" = "zb10"."baz170" ))

; 


/* 表 ABA1 的定义*/
CREATE TABLE "LOCAL_BDZGBGYY"."ABA1" (
  "AAB001" NUMBER(16)  NOT NULL ,    // 5: To_number("ab01"."aab001") = "aba1"."aab001" = 20017476,  To_number(NUMBER(16)) = NUMBER(20) ====>  修改为NUMBER(20)
  ... ...
  PRIMARY KEY ("AAZ001")
) ;

CREATE INDEX "LOCAL_BDZGBGYY"."IDX_ABA1_AAB001" on "LOCAL_BDZGBGYY"."ABA1" (
 "AAB001"
) GLOBAL ;  


/* 表 AB01 的定义 */
CREATE TABLE "EINP_BASICINFO"."AB01" (
... ...
  "AAB001" NUMBER(20)  NOT NULL,     // 8: To_number("ab01"."aab001") = "aba1"."aab001" = 20017476,  To_number(NUMBER(16)) = NUMBER(20)  
... ...
  PRIMARY KEY ("AAZ664")  
) ;

CREATE INDEX "EINP_BASICINFO"."IDX_AB01_AAB001" on "EINP_BASICINFO"."AB01" (
 "AAB001"
) GLOBAL ;  


/* 表 ZB10 的定义*/
CREATE TABLE "LOCAL_BDZGBGYY"."ZB10" (
  "BAZ170" VARCHAR2(20) NOT NULL,      // 11: "zb10"."baz170" = "ab01"."aab001" = 20017476, VARCHAR2(20) = NUMBER (20)  ====>  修改为NUMBER(20)
  ... ...                              // 14: "zb10"."baz170" = "abc1"."aaz509" = 20017476, VARCHAR2(20) = NUMBER (20)
  PRIMARY KEY ("AAZ001")
) ;

CREATE INDEX "LOCAL_BDZGBGYY"."IDX_ZB10_BAZ170" on "LOCAL_BDZGBGYY"."ZB10" (
 "BAZ170"
) GLOBAL ;

/* 表 ABC1 的定义 */
CREATE TABLE "SICP4_BASICINFOCENTER_EINP"."ABC1" (
  "AAZ509" NUMBER(20)  NOT NULL,      //  13: AAZ509 = 20017476
  ... ....
  PRIMARY KEY ("AAZ509")
) ;
```

综上，本案例中将表和视图 DDL 进行如下改造：

   * 关联字段定义统一为 NUMBER(20)
   * View 中去除 To_number 强制转换
   * 对 4 个关联表进行分区改造，使用关联建作为分区键，统一进行hash 分区，将资源消耗打散到不同 OBServer 节点上
   * 把 4 个关联表加入表组，这样可以直走本地执行计划

优化后 SQL 的 EXPLAIN 信息如下：

```sql
====================================================================
|ID|OPERATOR                |NAME                   |EST. ROWS|COST|
--------------------------------------------------------------------
|0 |PX COORDINATOR          |                       |3        |477 |
|1 | EXCHANGE OUT DISTR     |:EX10000               |3        |405 |
|2 |  SUBPLAN SCAN          |V_AB01                 |3        |405 |
|3 |   PX PARTITION ITERATOR|                       |3        |405 |
|4 |    UNION ALL           |                       |3        |405 |
|5 |     NESTED-LOOP JOIN   |                       |2        |273 |
|6 |      MERGE ANTI JOIN   |                       |2        |183 |
|7 |       TABLE SCAN       |AB01(INDX_AB01_AAB001) |2        |137 |
|8 |       SUBPLAN SCAN     |VIEW1                  |1        |46  |
|9 |        TABLE SCAN      |ZB10(INDEX_ZB10_BAZ170)|1        |46  |
|10|      TABLE SCAN        |ABA1(INDEX_ABA1_AAB001)|1        |44  |
|11|     NESTED-LOOP JOIN   |                       |1        |132 |
|12|      TABLE SCAN        |ZB10(INDEX_ZB10_BAZ170)|1        |92  |
|13|      TABLE GET         |ABC1                   |1        |40  |
====================================================================
```

v_ab01 视图 4 表分区后优化效果如下：