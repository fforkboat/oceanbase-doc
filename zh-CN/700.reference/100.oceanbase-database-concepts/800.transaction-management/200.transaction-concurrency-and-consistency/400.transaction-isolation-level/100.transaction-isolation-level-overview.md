# 事务隔离级别概述

隔离级别（Isolation，I in AC**I**D）用于描述事务并发执行时互相干扰的程度，ANSI/ISO SQL标准（SQL 92）基于事务执行过程中必须避免的异象定义了四种隔离级别，隔离级别越高，事务间的相互影响越小，允许出现的异象越少，在最高的隔离级别可串行化（Serializable）中，不允许出现任何异象。这些需要避免的异象包括：

* 脏读（Dirty Read）：一个事务读到其他事务尚未提交的数据。
* 不可重复读（Non Repeatable Read）：曾经读到的某行数据，再次查询发现该行数据已经被修改或者删除。例如：`select c2 from test where c1=1;`第一次查询 `c2` 的结果为 `1`，再次查询由于其他事务修改了 `c2` 的值，因此 `c2` 的结果为 `2`。
* 幻读（Phantom Read）：曾经读到一组满足搜索条件的行，再次执行时结果集中读到了另一个已提交事务**新插入**的满足条件的行。

四种隔离级别以及它们对上述异象的容忍程度如下所示：

|   隔离级别   | 脏读 | 不可重复读 | 幻读 |
|----------|----|-------|----|
| **读未提交（Read Uncommitted）** | 可能 | 可能 | 可能 |
| **读已提交（Read Committed）** | 不能 | 可能 | 可能 |
| **可重复读（Repeatable Read）** | 不能 | 不能 | 可能 |
| **可串行化（Serializable）** | 不能 | 不能 | 不能 |

OceanBase 数据库目前支持指定以下三种隔离级别：
  * 读已提交（Read Committed）
  * 可重复读（Repeatable Read）
  * 可串行化（Serializable）
 
不过目前在OceanBase内部只实现了两种隔离级别，即Read Committed和Serializable，当用户指定Repeatable Read的隔离级别时，实际使用的是Serializable。也就是说，OceanBase的Repeatable Read的隔离级别下不会出现幻读的异象。这一行为在SQL标准中是被允许的，因为SQL标准只限定了每个隔离级别**需要避免**的异象，没有强制要求**必须出现**的异象。

OceanBase 数据库默认的隔离级别为Read Committed。

## Read Committed隔离级别行为
每条`SELECT`语句会在执行之前获取当前数据库的快照，基于该快照，语句执行时能够读到在此之前所有已经提交事务的数据，而不会读到在语句执行过程中新提交或被并发事务修改的数据。由于每条语句执行前会获取新的快照，在同一个事务中连续的两条`SELECT`语句有可能看到不同的数据，即Read Committed隔离级别下不能避免不可重复读的异象。

对于`UPDATE`, `DELETE`, `SELECT FOR UPDATE`, `SELECT FOR SHARE`等更新性质的操作，它们在搜索目标行时的行为与`SELECT`相同，即只能找到在语句开始前已经提交的行。然而，当前事务（后称事务A）在搜索到一个目标行时，该行可能已经被另一个并发事务（后称事务B）更新了。在这种情况下，若事务B还没有结束，事务A需要等待事务B的提交或回滚。如果事务B回滚，事务A可以继续更新目标行。如果事务B提交，事务A将重新执行语句，从而重新获取语句快照，以读到最新的数据，在事务B更新后的版本上再进行更新。

## Serializable或Repeatable Read隔离级别行为
事务的第一条语句会获取当前数据库的快照作为事务快照，后续`SELECT`语句都会基于事务快照读取数据，能够读到在事务快照之前所有已经提交事务的数据，而不会读到在事务执行过程中新提交或被并发事务修改的数据。由于每条语句使用同一个事务快照，所以事务内总能看到一致的数据，不会出现不可重复读和幻读的异象。

对于`UPDATE`, `DELETE`, `SELECT FOR UPDATE`等更新性质的操作，它们在搜索目标行时的行为与`SELECT`相同，即只能找到在获取事务快照前已经提交的行。然而，当前事务（后称事务A）在搜索到一个目标行时，该行可能已经被另一个并发事务（后称事务B）更新了。在这种情况下，若事务B还没有结束，事务A需要等待事务B的提交或回滚。如果事务B回滚，事务A可以继续更新最初找到的行。如果事务B提交，事务A不能基于旧的快照进行更新，否则会出现丢失更新（Lost Update）的情况，因此事务A只能进行回滚，此时OceanBase会返回下列错误信息：
```
ERROR 6235 (25000): can't serialize access for this transaction
```
业务层需要考虑到事务可能会因为写写冲突而回滚，并准备事务重试逻辑。如果事务复杂，重试代价较大，且业务并不要求事务看到一致的数据情况，建议使用Read Committed的隔离级别。

## OceanBase Serializable隔离级别的限制
在SQL标准中，可串行化隔离级别只需要避免脏读、不可重复读和幻读的异象，但是可串行化的严格定义为：任何两个成功提交的并发事务将看起来像按顺序执行，一个在另一个之后，即事务的并行执行结果需要和某种串行执行的结果相同。

与Oracle、PostgreSQL 9.0及之前的版本类似，OceanBase的Serializable隔离级别下并不能保证严格的可串行化，即事务执行的结果可能不与任何串行执行模式的结果相同，一个经典的例子是写偏斜（Write Skew）：

假设存在表`T1(num int)`和`T2(num int)`，两个表初始都没有数据。此时在事务1（Trx1）和事务2（Trx2）中按照以下顺序执行命令，
```
Trx1                                                  Trx2
BEGIN;
INSERT INTO T2 SELECT COUNT(*) FROM T1;

                                                      BEGIN;
                                                      INSERT INTO T1 SELECT COUNT(*) FROM T2;
COMMIT;
                                                      COMMIT:
```
由于Trx1和Trx2获取的快照中两个表的COUNT都为0，最终表T1和表T2中都会插入num=0的一行，而假设事务1和事务2串行执行，无论是Trx1->Trx2还是Trx2->Trx1，最终两个表应该会分别插入num=0和num=1。

OceanBase目前无法保证严格可串行化的原因在于其读操作不会上锁，读写不互斥，并且也没有在事务提交时检查读写冲突是否成环。在大部分现实应用场景下，只要不出现脏读、幻读和不可重复读就能够满足业务的需求，如果业务一定需要严格的可串行化，可以显式地为读操作加锁，如`SELECT FOR UPDATE`。

## OceanBase隔离级别与其他数据库对比
|   数据库   | Read Uncommitted | Read Committed | Repeatable Read | Serializable |
|----------|----|-------|----|---|
| OceanBase | 不支持语法 | 支持 | 支持，且不存在幻读 | 支持，但不保证严格可串行化 |
| Oracle | 不支持语法 | 支持 | 不支持语法 | 支持，但不保证严格可串行化 |
| MySQL | 支持，有可能读到脏数据 | 支持 | 支持，且不存在幻读 | 支持，可以保证严格可串行化 |
| PostgreSQL 9.0及之前 | 支持语法，但实际是Read Committed | 支持 | 支持，且不存在幻读 | 支持，但不保证严格可串行化 |
| PostgreSQL 9.1及之后 | 支持语法，但实际是Read Committed | 支持 | 支持，且不存在幻读 | 支持，可以保证严格可串行化 |
